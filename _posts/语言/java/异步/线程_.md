---
title: 线程讲解
date: 2019-09-26T11:14:43.000Z
description: 线程讲解
categories:
    - 语言
    - java
    - 异步
tags:
    - 异步
    - 线程
---  
  
  

![](../../../../images/31887abb2a5323b401d8eb0871247dc70.png?0.5608443240039493)  
  
##  1. 线程池的创建规则
  
&emsp;线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。说明： Executors 返回的线程池对象的弊端如下：
1. FixedThreadPool 和 SingleThreadPool:
允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。
2. CachedThreadPool 和 ScheduledThreadPool:
允许的创建线程数量为 Integer.MAX_VALUE， 可能会创建大量的线程，从而导致 OOM。
  
##  2. blocking 和 waiting 的区别
  
###  2.1. BLOCKED状态
  
线程处于BLOCKED状态的场景。
  
当前线程在等待一个monitor lock，比如等待执行synchronized代码块或者使用synchronized标记的方法。
在synchronized块中循环调用Object类型的wait方法。
  
###  2.2. WAITING状态
  
线程处于WAITING状态的场景。
  
调用Object对象的wait方法，但没有指定超时值。
调用Thread对象的join方法，但没有指定超时值。
调用LockSupport对象的park方法。
提到WAITING状态，顺便提一下TIMED_WAITING状态的场景。
  
###  2.3. TIMED_WAITING状态
  
线程处于TIMED_WAITING状态的场景。
  
调用Thread.sleep方法。
调用Object对象的wait方法，指定超时值。
调用Thread对象的join方法，指定超时值。
调用LockSupport对象的parkNanos方法。
调用LockSupport对象的parkUntil方法。
  
##  3. 线程通信
  
###  3.1. Object.wait/notify
  
1. 通常和synchronized结合使用
2. 当拥有锁的线程调用Object.wait后，线程释放当前拥有的锁，并进入WAITING状态；
3. 当拥有锁的线程调用Object.notify后，通知其他线程可以开始竞争锁，但是当前线程不会主动释放锁。也就是说被通知的线程仍然拿不到锁。仅仅当synchronized代码块执行完后，当前线程释放锁，其他线程才能竞争到锁。
  
###  3.2. Condition.await/signal
  
1. 通常和Lock结合使用
2. 当拥有锁的线程调用Condition.await后，线程释放当前拥有的锁，并进入WAITING状态；
3. 当拥有锁的线程调用Condition.signal后，通知其他线程可以开始竞争锁，但是当前线程不会主动释放锁。也就是说被通知的线程仍然拿不到锁。仅仅当lock.unlock后，当前线程释放锁，其他线程才能竞争到锁。
  
  
  