---
title: 锁讲解
date: 2019-09-26T11:14:43.000Z
description: 锁讲解
categories:
    - 语言
    - java
    - 异步
tags:
    - 异步
    - 锁
---  
  

![](../../../../images/c10d8630f3d39c6b8c1379c6e9c5f0c30.png?0.13864491559923775)  
  
##  1. java 线程阻塞的代价
  
  
&emsp;java 的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统介入，需要在户与核心态之间切换，这种切换会消耗大量的系统资源，因为用户态与内核态都有各自专用的内存空间，专用寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。</br>
  
&emsp;如果线程状态切换是一个高频操作时，这将会消耗很多 CPU 处理时间；</br>
  
&emsp;如果对于那些需要同步的简单的代码块，获取锁挂起操作消耗的时间比用户代码执行的时间还要长，这种同策略显然非常糟糕的。</br>
  
&emsp;synchronized 会导致争用不到锁的线程进入阻塞状态，所以说它是 java 语言中一个重量级的同步操纵，被称重量级锁，为了缓解上述性能问题，JVM 从 1.5 开始，引入了轻量锁与偏向锁，默认启用了自旋锁，他们都属乐观锁。
  
##  2. markword
  
  
&emsp;在介绍 java 锁之前，先说下什么是 markword，markword 是 java 对象数据结构中的一部分，要详细了解 java 对象的结构可以点击这里,这里只做 markword 的详细介绍，因为对象的 markword 和 java 各种类型的锁密切相关；
&emsp;markword 数据的长度在 32 位和 64 位的虚拟机（未开启压缩指针）中分别为 32bit 和 64bit，它的最后 2bit 是锁状态标志位，用来标记当前对象的状态，对象的所处的状态，决定了 markword 存储的内容，如下表所示:
  
| 状态             | 标志位 | 存储内容                              |
| ---------------- | ------ | ------------------------------------- |
| 未锁定           | 01     | 对象哈希码、对象分代年龄              |
| 轻量级锁定       | 00     | 指向锁记录的指针                      |
| 膨胀(重量级锁定) | 10     | 执行重量级锁定的指针                  |
| GC 标记          | 11     | 空(不需要记录信息)                    |
| 可偏向           | 01     | 偏向线程 ID、偏向时间戳、对象分代年龄 |
  
##  3. 锁的特性
  
  
1. <strong> 公平锁、非公平锁 </strong>：公平锁指多个线程按照申请锁的顺序来获取锁，非公平锁就是没有顺序完全随机，所以能会造成优先级反转或者饥饿现象；synchronized 就是非公平锁，ReentrantLock（使用 CAS 和 AQS 实现） 通过构造参数可以决定是非公平锁还是公平锁，默认构造是非公平锁；非公平锁的吞吐量性能比公平锁大好。</br>
  
2. <strong> 可重入锁：又名递归锁 </strong>，指在同一个线程在外层方法获取锁的时候在进入内层方法会自动获取锁，synchronized 和 ReentrantLock 都是可重入锁，可重入锁可以在一定程度避免死锁。</br>
  
3. <strong> 独享锁、共享锁 </strong>：独享锁是指该锁一次只能被一个线程持有，共享锁指该锁可以被多个线程持有；synchronized 和 ReentrantLock 都是独享锁，ReadWriteLock 的读锁是共享锁，写锁是独占锁；ReentrantLock 的独享锁和共享锁也是通过 AQS 来实现的。</br>
  
4. <strong> 互斥锁、读写锁 </strong>：其实就是独享锁、共享锁的具体说法；互斥锁实质就是 ReentrantLock，读写锁实质就是 ReadWriteLock。</br>
  
5. <strong> 乐观锁、悲观锁 </strong>：这个分类不是具体锁的分类，而是看待并发同步的角度；悲观锁认为对于同一个数据的并发操作一定是会发生修改的（哪怕实质没修改也认为会修改），因此对于同一个数据的并发操作，悲观锁采取加锁的形式，因为悲观锁认为不加锁的操作一定有问题；乐观锁则认为对于同一个数据的并发操作是不会发生修改的，在更新数据的时候会采用不断的尝试更新，乐观锁认为不加锁的并发操作是没事的；由此可以看出悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升，悲观锁在 java 中很常见，乐观锁其实就是基于 CAS 的无锁编程，譬如 java 的原子类就是通过 CAS 自旋实现的。</br>
  
6. <strong> 分段锁 </strong>：实质是一种锁的设计策略，不是具体的锁，对于 ConcurrentHashMap 而言其并发的实现就是通过分段锁的形式来实现高效并发操作；当要 put 元素时并不是对整个 hashmap 加锁，而是先通过 hashcode 知道它要放在哪个分段，然后对分段进行加锁，所以多线程 put 元素时只要放在的不是同一个分段就做到了真正的并行插入，但是统计 size 时就需要获取所有的分段锁才能统计；分段锁的设计是为了细化锁的粒度。</br>
  
7. <strong> 偏向锁、轻量级锁、重量级锁 </strong>：这三种锁是指锁的状态，并且是针对 Synchronized。在 Java 5 通过引入锁升级的机制来实现高效 Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。
   偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
   轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
   重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</br>
  
8. <strong> 自旋锁 </strong>：其实是相对于互斥锁的概念，互斥锁线程会进入 WAITING 状态和 RUNNABLE 状态的切换，涉及上下文切换、cpu 抢占等开销，自旋锁的线程一直是 RUNNABLE 状态的，一直在那循环检测锁标志位，机制不重复，但是自旋锁加锁全程消耗 cpu，起始开销虽然低于互斥锁，但随着持锁时间加锁开销是线性增长。</br>
  
9. <strong> 可中断锁 </strong>：synchronized 是不可中断的，Lock 是可中断的，这里的可中断建立在阻塞等待中断，运行中是无法中断的。(这里的可中断应该是是否检查中断标示位设置)</br>
  
##  4. 中断线程
  
  
&emsp;线程的 thread.interrupt()方法是中断线程，将会设置该线程的中断状态位，即设置为 true，中断的结果线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序本身。线程会不时地检测这个中断标示位，以判断线程是否应该被中断（中断标示值是否为 true）。它并不像 stop 方法那样会中断一个正在运行的线程。
  
<strong> 判断线程是否被中断 </strong>
&emsp;判断某个线程是否已被发送过中断请求，请使用 Thread.currentThread().isInterrupted()方法（因为它将线程中断标示位设置为 true 后，不会立刻清除中断标示位，即不会将中断标设置为 false），而不要使用 thread.interrupted()（该方法调用后会将中断标示位清除，即重新设置为 false）方法来判断。
  
<strong> 如何中断线程 </strong>
&emsp;如果一个线程处于了阻塞状态（如线程调用了 thread.sleep、thread.join、thread.wait、1.5 中的 condition.await、以及可中断的通道上的 I/O 操作方法后可进入阻塞状态），则在线程在检查中断标示时如果发现中断标示为 true，则会在这些阻塞方法（sleep、join、wait、1.5 中的 condition.await 及可中断的通道上的 I/O 操作方法）调用处抛出 InterruptedException 异常，并且在抛出异常后立即将线程的中断标示位清除，即重新设置为 false。抛出异常是为了线程从阻塞状态醒过来，并在结束线程前让程序员有足够的时间来处理中断请求。
  
注：*synchronized 在获锁的过程中是不能被中断的，意思是说如果产生了死锁，则不可能被中断（请参考后面的测试例子）。与 synchronized 功能相似的 reentrantLock.lock()方法也是一样，它也不可中断的，即如果发生死锁，那么 reentrantLock.lock()方法无法终止，如果调用时被阻塞，则它一直阻塞到它获取到锁为止。但是如果调用带超时的 tryLock 方法 reentrantLock.tryLock(long timeout, TimeUnit unit)，那么如果线程在等待时被中断，将抛出一个 InterruptedException 异常，这是一个非常有用的特性，因为它允许程序打破死锁。你也可以调用 reentrantLock.lockInterruptibly()方法，它就相当于一个超时设为无限的 tryLock 方法。* 
  