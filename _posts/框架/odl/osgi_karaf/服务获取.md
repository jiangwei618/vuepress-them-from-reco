---
title: osgi框架简介
date: 2019-08-26 11:11:19
description: osgi框架简介
categories:
  - 框架
  - odl
  - osgi_karaf
tags:
  - osgi_karaf


---

## 1. osgi

### 1.1. BundleActivator

如果要对一个 bundle 进行生命周期管理，必须要在这个 bundle 中声明一个 bundle 激活器类，实现 org.osgi.framework.BundleActivator 接口。这个接口为 bundle 提供了挂接到生命周期层的钩子，同时自定义 bundle 在启动或停止时执行的操作。

<strong> 还必须在 MANIFEST.MF 中描述该 bundle 激活器： </strong>

```text
 Bundle-Activator: org.alpha.MyActivator
```

注意：并非所有 bundle 都需要一个激活器。只有当明确需要与 OSGI API 进行交互，或者需要执行自定义的初始化/销毁动作时，才必须要激活器。
当 bundle 被安装并启动以后，框架将构建相应的 BundleActivator 的一个实例，触发 BundleActivator.start()；
当 bundle 停止后，框架会调用 BundleActivator.stop()；stop()方法应该取消 start()中执行过的所有操作。

```java
 public   interface  BundleActivator {  
    public   void  start(BundleContext context)  throws  Exception;  
    public   void  stop(BundleContext context)  throws  Exception;  
 }  
```

<strong> 在 maven 管理的项目中，可以通过如下配置指定 BundleActivator </strong>

```xml
    <plugin>
        <groupId>org.apache.felix</groupId>
        <artifactId>maven-bundle-plugin</artifactId>
        <extensions>true</extensions>
        <configuration>
            <instructions>
                <Bundle-Activator>org.opendaylight.genius.fcapsmanager.alarmmanager.Activator</Bundle-Activator>
            </instructions>
        </configuration>
    </plugin>
```

### 1.2. BundleContext

BundleActivator 的两个方法都接受一个 BundleContext 对象作为参数。BundleContext 是 bundle 与 OSGi framework 通信的桥梁。BundleContext 可以做的事有：

```java
 Look up system-wide configuration properties;
 ——获取系统properties
 Find another installed bundle by its ID;
 ——通过ID查询已安装的其他bundle
 Obtain a list of all installed bundles;
 ——获取已安装的bundle列表
 Introspect and manipulate other bundles programmatically: start them, stop them, un-install them, update them, etc;
 ——在程序中操作其他bundle（启动、停止、卸载、更新）
 Install new bundles programmatically;
 ——在程序中安装新bundle
 Store or retrieve a file in a persistent storage area managed by the framework;
 ——往框架管理的持久化存储区中存储或查询文件
 Register and unregister bundle listeners, which tell us when the state of any bundle in the framework changes;
 ——注册bundle listener，监听bundle状态的改变
 Register and unregister service listeners, which tell us when the state of any service in the framework changes 
 ——注册service listener，监听service状态的改变 
 Register and unregister framework listeners, which tell us about general framework events.
 ——注册framework listener，监听一般框架事件
```

每个已激活的 bundle 都会接收到属于自己的 BundleContext 对象，该对象不能在 bundle 直接自由传递！

只有当 bundle 处于激活状态（从 start()开始，到 stop()结束），BundleContext 对象才是有效的。其他状态下调用该对象，会抛出异常。

```java
 public  interface  BundleContext {  
   String getProperty(String key);  
   Bundle getBundle();  
   Bundle getBundle( long  id);  
   Bundle[] getBundles();  
   
   Bundle installBundle(String location)  throws  BundleException;  
   Bundle installBundle(String location, InputStream input)  throws  BundleException;  
   
    void  addBundleListener(BundleListener listener);  
    void  removeBundleListener(BundleListener listener);  
    void  addFrameworkListener(FrameworkListener listener);  
    void  removeFrameworkListener(FrameworkListener listener);  
 }
```

<strong> BundleContext 的获取可以通过 BundleActivator 获取也可以通过 FrameworkUtil 获取 </strong>

## 2. karaf

### 2.1. karaf 服务获取

odl 服务获取有多种方式，除了利用 blueprint 在创建 bean 的时候获取，然后赋值给对象的属性，karaf 还提供了工具类，方便用户随时获取服务。代码如下：

```java

 public <T> T getService(T serviceRef, Class<T> serviceInterfaceClass) {

         if (serviceRef != null){
             return serviceRef;
         }

         BundleContext bundleContext = FrameworkUtil.getBundle(ElanServiceProvider.class).getBundleContext();
         ServiceTracker serviceTracker = new ServiceTracker<>(bundleContext, serviceInterfaceClass, null);
         serviceTracker.open();
         try {
             serviceRef = (T) serviceTracker.waitForService(100);
         } catch (InterruptedException e) {
             LOG.error("Error to get service {} , {}", serviceInterfaceClass, e);
         }
         serviceTracker.close();
         return serviceRef;
     }
```

WaitingServiceTracker 也可用来获取 service，不过在超时等待时会抛出 runtime 异常。其内部实现是对 ServiceTracker 的封装

```java

 public <T> T getService(T serviceRef, Class<T> serviceInterfaceClass) {

         if (serviceRef != null){
             return serviceRef;
         }

        BundleContext bundleContext = FrameworkUtil.getBundle(VnmanagerServiceUtil.class).getBundleContext();
        WaitingServiceTracker<T> serviceTracker = WaitingServiceTracker.create(serviceInterface, bundleContext);
         T serviceRef = serviceTracker.waitForService(WaitingServiceTracker.FIVE_MINUTES);
        serviceTracker.close();
         return serviceRef;
     }
```
