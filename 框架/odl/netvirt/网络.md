# 网络处理

## add
**主要流程**

{% uml %}
```plantuml
@startuml
start
    :neutron/network/network;
    fork
        :                 neutronVpn \n NeutronNetworkChangeListener;
    fork again
        :                 ipv6Service \n NeutronNetworkChangeListener;
    fork again
        :                 ipv6Service \n NeutronNetworkChangeListener;
    end fork
end

@enduml

```
{% enduml %}

**node1**
```
Create ietf-interfaces based on the ELAN segment type.
    For segment type flat - create transparent interface pointing to thepatch-port attached to the physnet port.<br>
    For segment type vlan - create trunk interface pointing to the patch-portattached to the physnet port + trunk-member interface pointing to thetrunk interface.
```

**node2**
```
使用非集群监听，并通过 ConcurrentMap<Uuid, Network> 缓存数据，若A为master时，创建网络并缓存，一旦集群震荡，B切换为master，此时删除网络，则A中ConcurrentMap会产生数据残留，
不清楚是否会影响业务，但是肯定会造成内存泄漏。
是否可以使用集群监听，所有节点均对缓存进行操作，但是仅仅只有owner处理业务逻辑EntityOwnershipUtils
```

#NeutronSubnetChangeListener
##add
{% uml %}
```plantuml

@startuml

PARTICIPANT "/config/neutron:neutron/subnets " as DsSubnets #99FF99

DsSubnets -->  NeutronSubnetChangeListener:数据库监听通知
activate NeutronSubnetChangeListener
NeutronSubnetChangeListener -> NeutronVpnUtils:getNeutronNetwork
PARTICIPANT "neutron\n:neutron/networks" as DsNetworks #99FF99
NeutronVpnUtils->DsNetworks:read && !=null && \n isNetworkTypeSupported(network)\n <color red>no</color>
NeutronSubnetChangeListener -> DsSubnets:game over
deactivate NeutronSubnetChangeListener

== 创建 subnet==

NeutronSubnetChangeListener --> NeutronVpnUtils:缓存
NeutronSubnetChangeListener -> NeutronSubnetChangeListener: handleNeutronSubnetCreated
NeutronSubnetChangeListener -> NeutronvpnManager:createSubnetmapNode
PARTICIPANT "config/neutronvpn:subnetmaps" as DsSubnetMaps #99FF99

NeutronSubnetChangeListener -> DsSubnetMaps:<color blue>write datastore</color>
NeutronSubnetChangeListener -> NeutronSubnetChangeListener:createSubnetToNetworkMapping
PARTICIPANT "/config/neutronvpn:networkMaps " as DsNetworkMaps #99FF99
NeutronSubnetChangeListener -> DsNetworkMaps:<color blue>write datastore</color>


== 外部网络处理  NeutronvpnUtils.getIsExternal(network) && NeutronvpnUtils.isFlatOrVlanNetwork(network)==
NeutronSubnetChangeListener -> NeutronExternalSubnetHandler:handleExternalSubnetAdded
NeutronExternalSubnetHandler -> NeutronvpnNatManager:updateOrAddExternalSubnet
NeutronvpnNatManager -> NeutronvpnUtils:getOptionalExternalSubnets
PARTICIPANT "config/odl-nat:external-subnets" as DsExternalSubnets #99FF99
NeutronvpnUtils -> DsExternalSubnets:read datastore
DsExternalSubnets --> NeutronVpnUtils
alt optionalExternalSubnets.isPresent()
    NeutronvpnNatManager -> NeutronvpnNatManager: updateExternalSubnet
    NeutronvpnNatManager -> DsExternalSubnets:<color blue>update datastore</color>
else
    NeutronvpnNatManager -> NeutronvpnNatManager:addExternalSubnet
    NeutronvpnNatManager -> DsExternalSubnets:<color blue>write datastore</color>
end
NeutronvpnNatManager -> NeutronExternalSubnetHandler
NeutronExternalSubnetHandler -> NeutronvpnManager:updateSubnetNode
NeutronvpnManager -> DsSubnetMaps:<color blue>update datastore routerId || vpnId </color>

NeutronExternalSubnetHandler -> NeutronvpnManager:createVpnInstanceForSubnet

PARTICIPANT "config/l3vpn:vpn-instances" as DsVpnInstance #99FF99
NeutronvpnManager -> DsVpnInstance:<color blue>write datastore </color>

@enduml

```
{% enduml %}


#NeutronRouterChangeListener
## add 
